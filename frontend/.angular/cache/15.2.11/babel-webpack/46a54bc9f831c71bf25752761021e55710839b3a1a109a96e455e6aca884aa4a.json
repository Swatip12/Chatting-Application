{"ast":null,"code":"import { Client } from '@stomp/stompjs';\nimport * as SockJS from 'sockjs-client';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { MessageType } from '../models/message.model';\nimport { UserStatus } from '../models/user.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./auth.service\";\nimport * as i2 from \"./notification.service\";\nimport * as i3 from \"./connection-status.service\";\nexport class ChatService {\n  constructor(authService, notificationService, connectionStatusService) {\n    this.authService = authService;\n    this.notificationService = notificationService;\n    this.connectionStatusService = connectionStatusService;\n    this.stompClient = null;\n    this.messageSubject = new Subject();\n    this.userStatusSubject = new BehaviorSubject([]);\n    this.connectionStatusSubject = new BehaviorSubject(false);\n    this.messageStatusSubject = new Subject();\n    this.subscriptions = [];\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectInterval = 5000; // 5 seconds\n  }\n\n  connect() {\n    const currentUser = this.authService.getCurrentUser();\n    if (!currentUser) {\n      console.error('Cannot connect: No authenticated user');\n      return;\n    }\n    if (this.stompClient && this.stompClient.connected) {\n      console.log('Already connected to WebSocket');\n      return;\n    }\n    // Create STOMP client with SockJS\n    this.stompClient = new Client({\n      webSocketFactory: () => new SockJS('http://localhost:8080/ws/chat'),\n      connectHeaders: {\n        username: currentUser.username\n      },\n      debug: str => {\n        console.log('STOMP Debug:', str);\n      },\n      reconnectDelay: this.reconnectInterval,\n      heartbeatIncoming: 4000,\n      heartbeatOutgoing: 4000\n    });\n    // Connection success callback\n    this.stompClient.onConnect = frame => {\n      console.log('Connected to WebSocket:', frame);\n      this.connectionStatusSubject.next(true);\n      this.reconnectAttempts = 0;\n      this.notificationService.showSuccess('Connected to chat server');\n      this.setupSubscriptions();\n      this.notifyUserJoined();\n    };\n    // Connection error callback\n    this.stompClient.onStompError = frame => {\n      console.error('STOMP error:', frame);\n      this.connectionStatusSubject.next(false);\n      this.notificationService.showError('Chat connection error. Attempting to reconnect...');\n      this.handleReconnection();\n    };\n    // WebSocket error callback\n    this.stompClient.onWebSocketError = error => {\n      console.error('WebSocket error:', error);\n      this.connectionStatusSubject.next(false);\n      this.notificationService.showError('Connection to chat server lost. Attempting to reconnect...');\n      this.handleReconnection();\n    };\n    // Disconnect callback\n    this.stompClient.onDisconnect = () => {\n      console.log('Disconnected from WebSocket');\n      this.connectionStatusSubject.next(false);\n      this.clearSubscriptions();\n    };\n    // Activate the client\n    this.stompClient.activate();\n  }\n  setupSubscriptions() {\n    if (!this.stompClient || !this.stompClient.connected) {\n      return;\n    }\n    const currentUser = this.authService.getCurrentUser();\n    if (!currentUser) {\n      return;\n    }\n    // Subscribe to private messages\n    const privateMessageSub = this.stompClient.subscribe(`/user/${currentUser.username}/queue/messages`, message => {\n      const chatMessage = JSON.parse(message.body);\n      this.handleIncomingMessage(chatMessage);\n    });\n    // Subscribe to public messages (for group chats and notifications)\n    const publicMessageSub = this.stompClient.subscribe('/topic/public', message => {\n      const chatMessage = JSON.parse(message.body);\n      this.handleIncomingMessage(chatMessage);\n    });\n    // Subscribe to user status updates\n    const userStatusSub = this.stompClient.subscribe('/topic/users', message => {\n      const statusMessage = JSON.parse(message.body);\n      this.handleUserStatusUpdate(statusMessage);\n    });\n    this.subscriptions.push(privateMessageSub, publicMessageSub, userStatusSub);\n  }\n  /**\r\n   * Subscribe to a specific group's messages\r\n   */\n  subscribeToGroup(groupId) {\n    if (!this.stompClient || !this.stompClient.connected) {\n      console.error('Cannot subscribe to group: Not connected to WebSocket');\n      return;\n    }\n    const groupSub = this.stompClient.subscribe(`/topic/group/${groupId}`, message => {\n      const chatMessage = JSON.parse(message.body);\n      this.handleIncomingMessage(chatMessage);\n    });\n    this.subscriptions.push(groupSub);\n    console.log(`Subscribed to group: ${groupId}`);\n  }\n  /**\r\n   * Unsubscribe from a specific group's messages\r\n   */\n  unsubscribeFromGroup(groupId) {\n    // Note: In a more sophisticated implementation, we would track subscriptions by group ID\n    // For now, we rely on the automatic cleanup when disconnecting\n    console.log(`Unsubscribed from group: ${groupId}`);\n  }\n  handleIncomingMessage(chatMessage) {\n    // Convert ChatMessage to Message format\n    const message = {\n      sender: {\n        id: 0,\n        username: chatMessage.sender,\n        status: UserStatus.ONLINE\n      },\n      receiver: chatMessage.receiver ? {\n        id: 0,\n        username: chatMessage.receiver,\n        status: UserStatus.ONLINE\n      } : undefined,\n      content: chatMessage.content,\n      type: chatMessage.type,\n      timestamp: new Date(),\n      groupId: chatMessage.groupId\n    };\n    this.messageSubject.next(message);\n  }\n  handleUserStatusUpdate(statusMessage) {\n    // Update user list based on status changes\n    this.authService.getUsers().subscribe({\n      next: users => {\n        this.userStatusSubject.next(users);\n      },\n      error: error => {\n        console.error('Error updating user list:', error);\n      }\n    });\n  }\n  notifyUserJoined() {\n    const currentUser = this.authService.getCurrentUser();\n    if (!currentUser || !this.stompClient) {\n      return;\n    }\n    const joinMessage = {\n      sender: currentUser.username,\n      content: `${currentUser.username} joined the chat`,\n      type: MessageType.JOIN\n    };\n    this.stompClient.publish({\n      destination: '/app/chat.addUser',\n      body: JSON.stringify(joinMessage)\n    });\n  }\n  sendMessage(message) {\n    if (!this.stompClient || !this.stompClient.connected) {\n      console.error('Cannot send message: Not connected to WebSocket');\n      this.notificationService.showError('Cannot send message: Not connected to chat server');\n      return;\n    }\n    try {\n      const messageId = `msg-${Date.now()}-${Math.random()}`;\n      // Emit sending status\n      this.messageStatusSubject.next({\n        messageId,\n        status: 'sending'\n      });\n      const chatMessage = {\n        sender: message.sender.username,\n        receiver: message.receiver?.username,\n        content: message.content,\n        type: message.type,\n        groupId: message.groupId\n      };\n      const destination = message.groupId ? '/app/chat.sendGroupMessage' : '/app/chat.sendMessage';\n      this.stompClient.publish({\n        destination: destination,\n        body: JSON.stringify(chatMessage)\n      });\n      // Add message to local message stream for immediate display\n      const messageWithId = {\n        ...message,\n        id: messageId\n      };\n      this.messageSubject.next(messageWithId);\n      // Emit sent status after a short delay (simulating server processing)\n      setTimeout(() => {\n        this.messageStatusSubject.next({\n          messageId,\n          status: 'sent'\n        });\n      }, 100);\n    } catch (error) {\n      console.error('Error sending message:', error);\n      this.notificationService.showError('Failed to send message. Please try again.');\n      // Emit failed status\n      const messageId = `msg-${Date.now()}-${Math.random()}`;\n      this.messageStatusSubject.next({\n        messageId,\n        status: 'failed'\n      });\n    }\n  }\n  sendGroupMessage(message, groupId) {\n    message.groupId = groupId;\n    this.sendMessage(message);\n  }\n  subscribeToMessages() {\n    return this.messageSubject.asObservable();\n  }\n  subscribeToUserStatus() {\n    return this.userStatusSubject.asObservable();\n  }\n  getConnectionStatus() {\n    return this.connectionStatusSubject.asObservable();\n  }\n  getMessageStatus() {\n    return this.messageStatusSubject.asObservable();\n  }\n  disconnect() {\n    const currentUser = this.authService.getCurrentUser();\n    if (currentUser && this.stompClient && this.stompClient.connected) {\n      // Notify that user is leaving\n      const leaveMessage = {\n        sender: currentUser.username,\n        content: `${currentUser.username} left the chat`,\n        type: MessageType.LEAVE\n      };\n      this.stompClient.publish({\n        destination: '/app/chat.removeUser',\n        body: JSON.stringify(leaveMessage)\n      });\n    }\n    this.clearSubscriptions();\n    if (this.stompClient) {\n      this.stompClient.deactivate();\n      this.stompClient = null;\n    }\n    this.connectionStatusSubject.next(false);\n  }\n  clearSubscriptions() {\n    this.subscriptions.forEach(sub => {\n      if (sub) {\n        sub.unsubscribe();\n      }\n    });\n    this.subscriptions = [];\n  }\n  handleReconnection() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      // Use exponential backoff for reconnection attempts\n      const backoffDelay = this.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1);\n      setTimeout(() => {\n        if (!this.stompClient?.connected) {\n          this.notificationService.showInfo(`Reconnecting to chat server... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n          this.connect();\n        }\n      }, Math.min(backoffDelay, 30000)); // Cap at 30 seconds\n    } else {\n      console.error('Max reconnection attempts reached. Please refresh the page.');\n      this.notificationService.showError('Unable to reconnect to chat server. Please refresh the page.');\n    }\n  }\n  isConnected() {\n    return this.stompClient?.connected || false;\n  }\n  static {\n    this.ɵfac = function ChatService_Factory(t) {\n      return new (t || ChatService)(i0.ɵɵinject(i1.AuthService), i0.ɵɵinject(i2.NotificationService), i0.ɵɵinject(i3.ConnectionStatusService));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ChatService,\n      factory: ChatService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["Client","SockJS","BehaviorSubject","Subject","MessageType","UserStatus","ChatService","constructor","authService","notificationService","connectionStatusService","connect","currentUser","getCurrentUser","console","error","stompClient","connected","log","webSocketFactory","connectHeaders","username","debug","str","reconnectDelay","reconnectInterval","heartbeatIncoming","heartbeatOutgoing","onConnect","frame","connectionStatusSubject","next","reconnectAttempts","showSuccess","setupSubscriptions","notifyUserJoined","onStompError","showError","handleReconnection","onWebSocketError","onDisconnect","clearSubscriptions","activate","privateMessageSub","subscribe","message","chatMessage","JSON","parse","body","handleIncomingMessage","publicMessageSub","userStatusSub","statusMessage","handleUserStatusUpdate","subscriptions","push","subscribeToGroup","groupId","groupSub","unsubscribeFromGroup","sender","id","status","ONLINE","receiver","undefined","content","type","timestamp","Date","messageSubject","getUsers","users","userStatusSubject","joinMessage","JOIN","publish","destination","stringify","sendMessage","messageId","now","Math","random","messageStatusSubject","messageWithId","setTimeout","sendGroupMessage","subscribeToMessages","asObservable","subscribeToUserStatus","getConnectionStatus","getMessageStatus","disconnect","leaveMessage","LEAVE","deactivate","forEach","sub","unsubscribe","maxReconnectAttempts","backoffDelay","pow","showInfo","min","isConnected","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\swatip\\Documents\\FSD Projects\\Chatting-Application\\frontend\\src\\app\\services\\chat.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Client, StompSubscription } from '@stomp/stompjs';\r\nimport * as SockJS from 'sockjs-client';\r\nimport { BehaviorSubject, Observable, Subject } from 'rxjs';\r\nimport { Message, ChatMessage, UserStatusMessage, MessageType } from '../models/message.model';\r\nimport { User, UserStatus } from '../models/user.model';\r\nimport { AuthService } from './auth.service';\r\nimport { NotificationService } from './notification.service';\r\nimport { ConnectionStatusService } from './connection-status.service';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ChatService {\r\n  private stompClient: Client | null = null;\r\n  private messageSubject = new Subject<Message>();\r\n  private userStatusSubject = new BehaviorSubject<User[]>([]);\r\n  private connectionStatusSubject = new BehaviorSubject<boolean>(false);\r\n  private messageStatusSubject = new Subject<{messageId: string, status: 'sending' | 'sent' | 'delivered' | 'failed'}>();\r\n  \r\n  private subscriptions: StompSubscription[] = [];\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectInterval = 5000; // 5 seconds\r\n\r\n  constructor(\r\n    private authService: AuthService,\r\n    private notificationService: NotificationService,\r\n    private connectionStatusService: ConnectionStatusService\r\n  ) {}\r\n\r\n  connect(): void {\r\n    const currentUser = this.authService.getCurrentUser();\r\n    if (!currentUser) {\r\n      console.error('Cannot connect: No authenticated user');\r\n      return;\r\n    }\r\n\r\n    if (this.stompClient && this.stompClient.connected) {\r\n      console.log('Already connected to WebSocket');\r\n      return;\r\n    }\r\n\r\n    // Create STOMP client with SockJS\r\n    this.stompClient = new Client({\r\n      webSocketFactory: () => new SockJS('http://localhost:8080/ws/chat'),\r\n      connectHeaders: {\r\n        username: currentUser.username\r\n      },\r\n      debug: (str: string) => {\r\n        console.log('STOMP Debug:', str);\r\n      },\r\n      reconnectDelay: this.reconnectInterval,\r\n      heartbeatIncoming: 4000,\r\n      heartbeatOutgoing: 4000,\r\n    });\r\n\r\n    // Connection success callback\r\n    this.stompClient.onConnect = (frame: any) => {\r\n      console.log('Connected to WebSocket:', frame);\r\n      this.connectionStatusSubject.next(true);\r\n      this.reconnectAttempts = 0;\r\n      this.notificationService.showSuccess('Connected to chat server');\r\n      this.setupSubscriptions();\r\n      this.notifyUserJoined();\r\n    };\r\n\r\n    // Connection error callback\r\n    this.stompClient.onStompError = (frame: any) => {\r\n      console.error('STOMP error:', frame);\r\n      this.connectionStatusSubject.next(false);\r\n      this.notificationService.showError('Chat connection error. Attempting to reconnect...');\r\n      this.handleReconnection();\r\n    };\r\n\r\n    // WebSocket error callback\r\n    this.stompClient.onWebSocketError = (error: any) => {\r\n      console.error('WebSocket error:', error);\r\n      this.connectionStatusSubject.next(false);\r\n      this.notificationService.showError('Connection to chat server lost. Attempting to reconnect...');\r\n      this.handleReconnection();\r\n    };\r\n\r\n    // Disconnect callback\r\n    this.stompClient.onDisconnect = () => {\r\n      console.log('Disconnected from WebSocket');\r\n      this.connectionStatusSubject.next(false);\r\n      this.clearSubscriptions();\r\n    };\r\n\r\n    // Activate the client\r\n    this.stompClient.activate();\r\n  }\r\n\r\n  private setupSubscriptions(): void {\r\n    if (!this.stompClient || !this.stompClient.connected) {\r\n      return;\r\n    }\r\n\r\n    const currentUser = this.authService.getCurrentUser();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    // Subscribe to private messages\r\n    const privateMessageSub = this.stompClient.subscribe(\r\n      `/user/${currentUser.username}/queue/messages`,\r\n      (message: any) => {\r\n        const chatMessage: ChatMessage = JSON.parse(message.body);\r\n        this.handleIncomingMessage(chatMessage);\r\n      }\r\n    );\r\n\r\n    // Subscribe to public messages (for group chats and notifications)\r\n    const publicMessageSub = this.stompClient.subscribe(\r\n      '/topic/public',\r\n      (message: any) => {\r\n        const chatMessage: ChatMessage = JSON.parse(message.body);\r\n        this.handleIncomingMessage(chatMessage);\r\n      }\r\n    );\r\n\r\n    // Subscribe to user status updates\r\n    const userStatusSub = this.stompClient.subscribe(\r\n      '/topic/users',\r\n      (message: any) => {\r\n        const statusMessage: UserStatusMessage = JSON.parse(message.body);\r\n        this.handleUserStatusUpdate(statusMessage);\r\n      }\r\n    );\r\n\r\n    this.subscriptions.push(privateMessageSub, publicMessageSub, userStatusSub);\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a specific group's messages\r\n   */\r\n  subscribeToGroup(groupId: string): void {\r\n    if (!this.stompClient || !this.stompClient.connected) {\r\n      console.error('Cannot subscribe to group: Not connected to WebSocket');\r\n      return;\r\n    }\r\n\r\n    const groupSub = this.stompClient.subscribe(\r\n      `/topic/group/${groupId}`,\r\n      (message: any) => {\r\n        const chatMessage: ChatMessage = JSON.parse(message.body);\r\n        this.handleIncomingMessage(chatMessage);\r\n      }\r\n    );\r\n\r\n    this.subscriptions.push(groupSub);\r\n    console.log(`Subscribed to group: ${groupId}`);\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from a specific group's messages\r\n   */\r\n  unsubscribeFromGroup(groupId: string): void {\r\n    // Note: In a more sophisticated implementation, we would track subscriptions by group ID\r\n    // For now, we rely on the automatic cleanup when disconnecting\r\n    console.log(`Unsubscribed from group: ${groupId}`);\r\n  }\r\n\r\n  private handleIncomingMessage(chatMessage: ChatMessage): void {\r\n    // Convert ChatMessage to Message format\r\n    const message: Message = {\r\n      sender: { \r\n        id: 0, // Will be populated from backend\r\n        username: chatMessage.sender, \r\n        status: UserStatus.ONLINE \r\n      },\r\n      receiver: chatMessage.receiver ? { \r\n        id: 0, \r\n        username: chatMessage.receiver, \r\n        status: UserStatus.ONLINE \r\n      } : undefined,\r\n      content: chatMessage.content,\r\n      type: chatMessage.type,\r\n      timestamp: new Date(),\r\n      groupId: chatMessage.groupId\r\n    };\r\n\r\n    this.messageSubject.next(message);\r\n  }\r\n\r\n  private handleUserStatusUpdate(statusMessage: UserStatusMessage): void {\r\n    // Update user list based on status changes\r\n    this.authService.getUsers().subscribe({\r\n      next: (users: User[]) => {\r\n        this.userStatusSubject.next(users);\r\n      },\r\n      error: (error: any) => {\r\n        console.error('Error updating user list:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  private notifyUserJoined(): void {\r\n    const currentUser = this.authService.getCurrentUser();\r\n    if (!currentUser || !this.stompClient) {\r\n      return;\r\n    }\r\n\r\n    const joinMessage: ChatMessage = {\r\n      sender: currentUser.username,\r\n      content: `${currentUser.username} joined the chat`,\r\n      type: MessageType.JOIN\r\n    };\r\n\r\n    this.stompClient.publish({\r\n      destination: '/app/chat.addUser',\r\n      body: JSON.stringify(joinMessage)\r\n    });\r\n  }\r\n\r\n  sendMessage(message: Message): void {\r\n    if (!this.stompClient || !this.stompClient.connected) {\r\n      console.error('Cannot send message: Not connected to WebSocket');\r\n      this.notificationService.showError('Cannot send message: Not connected to chat server');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const messageId = `msg-${Date.now()}-${Math.random()}`;\r\n      \r\n      // Emit sending status\r\n      this.messageStatusSubject.next({messageId, status: 'sending'});\r\n\r\n      const chatMessage: ChatMessage = {\r\n        sender: message.sender.username,\r\n        receiver: message.receiver?.username,\r\n        content: message.content,\r\n        type: message.type,\r\n        groupId: message.groupId\r\n      };\r\n\r\n      const destination = message.groupId \r\n        ? '/app/chat.sendGroupMessage' \r\n        : '/app/chat.sendMessage';\r\n\r\n      this.stompClient.publish({\r\n        destination: destination,\r\n        body: JSON.stringify(chatMessage)\r\n      });\r\n\r\n      // Add message to local message stream for immediate display\r\n      const messageWithId = { ...message, id: messageId };\r\n      this.messageSubject.next(messageWithId);\r\n      \r\n      // Emit sent status after a short delay (simulating server processing)\r\n      setTimeout(() => {\r\n        this.messageStatusSubject.next({messageId, status: 'sent'});\r\n      }, 100);\r\n      \r\n    } catch (error) {\r\n      console.error('Error sending message:', error);\r\n      this.notificationService.showError('Failed to send message. Please try again.');\r\n      // Emit failed status\r\n      const messageId = `msg-${Date.now()}-${Math.random()}`;\r\n      this.messageStatusSubject.next({messageId, status: 'failed'});\r\n    }\r\n  }\r\n\r\n  sendGroupMessage(message: Message, groupId: string): void {\r\n    message.groupId = groupId;\r\n    this.sendMessage(message);\r\n  }\r\n\r\n  subscribeToMessages(): Observable<Message> {\r\n    return this.messageSubject.asObservable();\r\n  }\r\n\r\n  subscribeToUserStatus(): Observable<User[]> {\r\n    return this.userStatusSubject.asObservable();\r\n  }\r\n\r\n  getConnectionStatus(): Observable<boolean> {\r\n    return this.connectionStatusSubject.asObservable();\r\n  }\r\n\r\n  getMessageStatus(): Observable<{messageId: string, status: 'sending' | 'sent' | 'delivered' | 'failed'}> {\r\n    return this.messageStatusSubject.asObservable();\r\n  }\r\n\r\n  disconnect(): void {\r\n    const currentUser = this.authService.getCurrentUser();\r\n    \r\n    if (currentUser && this.stompClient && this.stompClient.connected) {\r\n      // Notify that user is leaving\r\n      const leaveMessage: ChatMessage = {\r\n        sender: currentUser.username,\r\n        content: `${currentUser.username} left the chat`,\r\n        type: MessageType.LEAVE\r\n      };\r\n\r\n      this.stompClient.publish({\r\n        destination: '/app/chat.removeUser',\r\n        body: JSON.stringify(leaveMessage)\r\n      });\r\n    }\r\n\r\n    this.clearSubscriptions();\r\n    \r\n    if (this.stompClient) {\r\n      this.stompClient.deactivate();\r\n      this.stompClient = null;\r\n    }\r\n    \r\n    this.connectionStatusSubject.next(false);\r\n  }\r\n\r\n  private clearSubscriptions(): void {\r\n    this.subscriptions.forEach(sub => {\r\n      if (sub) {\r\n        sub.unsubscribe();\r\n      }\r\n    });\r\n    this.subscriptions = [];\r\n  }\r\n\r\n  private handleReconnection(): void {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\r\n      \r\n      // Use exponential backoff for reconnection attempts\r\n      const backoffDelay = this.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1);\r\n      \r\n      setTimeout(() => {\r\n        if (!this.stompClient?.connected) {\r\n          this.notificationService.showInfo(`Reconnecting to chat server... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\r\n          this.connect();\r\n        }\r\n      }, Math.min(backoffDelay, 30000)); // Cap at 30 seconds\r\n    } else {\r\n      console.error('Max reconnection attempts reached. Please refresh the page.');\r\n      this.notificationService.showError('Unable to reconnect to chat server. Please refresh the page.');\r\n    }\r\n  }\r\n\r\n  isConnected(): boolean {\r\n    return this.stompClient?.connected || false;\r\n  }\r\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}